#include <fmt/printf.h>
#include <args.hxx>
#include <filesystem>
#include <iostream>
#include <stdexcept>
#include <qrencode.h>
#include "Util.h"
#include "Server.h"
#include <fmt/color.h>


//! List all the available ip addresses, prompt the user to select one via stdin, return the selected address
std::string ChooseInterface() {
    auto interfaces = Util::ListInterfaces();
    std::sort(interfaces.begin(), interfaces.end());
    unsigned int n = 0;
    std::cout << "Choose a network address by its number \n";
    for (const auto i : interfaces) {
        fmt::printf(" %d -> %s (%s) \n", n, i.address, i.name);
        n++;
    }
    std::cout << "\nInput number: ";

    std::cin >> n;
    if (n >= interfaces.size()) {
        std::cerr << "invalid index" << std::endl;
        //throw std::invalid_argument("invalid index");
        return std::string{};
    }

    return interfaces[n].address;
}

//! Generate a qrcode from a string and print it to stdout, converts the bitmap generated by QRcode_encodeString to an ascii art
template <typename T> void printQr_generic(const std::string &url, const T pixel)
{
	std::stringstream ss{};
	QRcode *qrcode = QRcode_encodeString(url.c_str(), 1, QR_ECLEVEL_M, QR_MODE_8, 1);
	unsigned char *data = qrcode->data;
	const size_t size = qrcode->width;

	for (int r = 0; r < size + 2; r++)
	{
		ss << ' ' << pixel;
		for (int c = 0; c < size; c++)
		{
			if (r == 0 || r > size)
			{ //first and last row
				ss << pixel << pixel;
			}
			else
			{
				if (*data & 1)
					ss << "  ";
				else
					ss << pixel << pixel;
				data++;
			}
		}
		ss << pixel << '\n';
	}
	std::cout << '\n' << ss.str() << std::endl;
	QRcode_free(qrcode);
}

void printQr(const std::string &url)
{
#ifdef _WIN32
	printQr_generic<char>(url, 219); // windows will gladly use an extended ASCII
#else
	printQr_generic<std::string>(url, u8"\u2588"); // a posix system needs a real utf8 character
#endif
}

int main(int argc, char **argv) {
    unsigned short port = 8080;
    srand((unsigned int)time(nullptr));
    std::string file_path;
    //parse the commandline options
    args::ArgumentParser parser("qr-filentransfer-cpp", "");
    args::HelpFlag help(parser, "help", "Display this help menu", {'h', "help"});
    args::ValueFlag<std::string> served_path(parser, "servedpath", "The path the server will listen to. A random one will be generated if omitted", {'s'});
    args::ValueFlag<unsigned short> port_number(parser, "port", "The port the server will listen to. A random one will be generated if omitted", {'p'});
    args::Group group(parser);
    args::Flag keep(group, "keep-alive", "keeps server alive, won't shut it down after transfer", {'k', "keep-alive"});
    args::Flag receive(group, "receive", "allows the client to send files", {'r', "receive"});
    args::Flag verbose(group, "verbose", "print more status messages", {'v', "verbose"});
    args::Positional<std::string> filename(parser, "filename", "file to serve");
    try {
        parser.ParseCLI(argc, argv);
    } catch (const args::Completion &e) {
        std::cout << e.what();
        return -1;
    } catch (const args::Help &) {
        std::cout << parser;
        return -2;
    } catch (const args::ParseError &e) {
        std::cerr << e.what() << std::endl;
        std::cerr << parser;
        return -3;
    } catch (const std::exception &e) {
        std::cerr << e.what() << std::endl;
    }
    if (filename) {
        std::cout << filename.Get() << " will be served" << std::endl;
        file_path = filename.Get();
        if (!std::filesystem::exists(file_path)) {
            const auto abspath = std::filesystem::absolute(file_path);
            std::cerr << "The file '" << abspath << "' does not exist or it's impossible to open" << std::endl;
            return -4;        
		}
    } else {
        std::cerr << "A filename is needed \n";
        std::cout << parser;
        return -1;
    }
    if (port_number)
        port = port_number.Get();
    else
        port = (rand() % 49153) + 16382;

    auto addr = ChooseInterface();
	if (addr.length() == 0)
		return -1;
    fmt::printf("Binding to -> %s\n", addr);
    std::string rand_path;
    if (served_path)
        rand_path = args::get(served_path);
    else
        rand_path = Util::RandomizePath(file_path);

    std::string path = fmt::sprintf("http://%s:%d/%s", addr, port, rand_path);
    fmt::printf("The served url is -> %s\n", path);
    printQr(path);
    QrFileTransfer::Server server{addr, port, file_path, rand_path, keep.Get(), receive, verbose};
	server.Start(true);
    printf("Server is ready\n");
    server.Wait();
    return 0;
}
